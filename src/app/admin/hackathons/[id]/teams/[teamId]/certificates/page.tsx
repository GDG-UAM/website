"use client";

import { api } from "@/lib/eden";
import { useState, useEffect, Suspense } from "react";
import { useParams, useRouter } from "next/navigation";
import styled from "styled-components";
import CertificateList from "@/components/pages/admin/certificates/CertificateList";
import CertificateForm, {
  CertificateFormData
} from "@/components/pages/admin/certificates/CertificateForm";
import Certificate from "@/components/Certificate";
import { BackButton } from "@/components/Buttons";
import AdminBreadcrumbs from "@/components/AdminBreadcrumbs";
import { newErrorToast, newSuccessToast } from "@/components/_toasts/toastEmitter";
import { useTranslations } from "next-intl";
import { getCsrfToken } from "@/lib/security/csrfClient";

const Container = styled.div`
  padding: 20px;
  max-width: 1400px;
  margin: 0 auto;
`;

const Header = styled.div`
  margin-bottom: 20px;
`;

const Title = styled.h1`
  font-size: 2rem;
  font-weight: 600;
  margin: 0 0 8px 0;
`;

const Subtitle = styled.h2`
  font-size: 1.25rem;
  font-weight: 500;
  color: #6b7280;
  margin: 0 0 16px 0;
`;

type Mode = "list" | "create" | "edit" | "preview" | "team-emit";

export default function TeamCertificatesPage() {
  return (
    <Suspense fallback={<div>Loading...</div>}>
      <TeamCertificatesContent />
    </Suspense>
  );
}

function TeamCertificatesContent() {
  const params = useParams();
  const id = params?.id as string;
  const teamId = params?.teamId as string;
  const router = useRouter();

  const t = useTranslations("admin.certificates.toasts");
  const tPage = useTranslations("admin.certificates.page");
  const tTeams = useTranslations("admin.hackathons.teams");
  const tBreadcrumbs = useTranslations("admin.breadcrumbs");

  const [mode, setMode] = useState<Mode>("list");
  const [editingId, setEditingId] = useState<string | null>(null);
  const [previewId, setPreviewId] = useState<string | null>(null);
  const [refreshToken, setRefreshToken] = useState(0);
  const [initial, setInitial] = useState<Partial<CertificateFormData>>();
  const [team, setTeam] = useState<{ name: string } | null>(null);
  const [hackathon, setHackathon] = useState<{
    title: string;
    date: string;
    endDate: string;
    certificateDefaults?: {
      title?: string | null;
      signatures?: Array<{
        name?: string;
        role?: string;
        imageUrl?: string;
      }>;
    } | null;
  } | null>(null);

  useEffect(() => {
    (async () => {
      try {
        const [teamRes, hackRes] = await Promise.all([
          api.admin.hackathons.teams({ teamId }).get(),
          fetch(`/api/admin/hackathons/${id}`).then((r) => r.json())
        ]);

        if (teamRes.data) setTeam(teamRes.data);
        if (hackRes) setHackathon(hackRes);
      } catch (e) {
        console.error("Failed to load team/hackathon info", e);
      }
    })();
  }, [id, teamId]);

  const onEmitBulk = () => {
    setInitial({
      teamId,
      hackathonId: id,
      autoGenerated: true,
      title: hackathon?.certificateDefaults?.title || hackathon?.title,
      signatures: hackathon?.certificateDefaults?.signatures || [],
      period: {
        startDate: hackathon?.date ? new Date(hackathon.date).toISOString().split("T")[0] : "",
        endDate: hackathon?.endDate ? new Date(hackathon.endDate).toISOString().split("T")[0] : ""
      }
    });
    setMode("team-emit");
  };

  const onEdit = (id: string) => {
    setEditingId(id);
    setMode("edit");
  };

  const onView = (id: string) => {
    setPreviewId(id);
    setMode("preview");
  };

  const goList = () => {
    setMode("list");
    setEditingId(null);
    setPreviewId(null);
    setInitial(undefined);
    setRefreshToken((x) => x + 1);
  };

  // Load certificate data when editing
  useEffect(() => {
    if (mode === "edit" && editingId) {
      (async () => {
        try {
          const { data, error } = await api.admin.certificates({ id: editingId }).get();
          if (error || !data) {
            newErrorToast(t("loadError"));
            goList();
            return;
          }

          setInitial({
            type: data.type as CertificateFormData["type"],
            title: data.title,
            description: data.description || "",
            designId: data.designId,
            recipient: {
              name: data.recipient.name,
              userId: data.recipient.userId?.toString() || ""
            },
            period: data.period
              ? {
                  startDate: data.period.startDate
                    ? new Date(data.period.startDate).toISOString().split("T")[0]
                    : "",
                  endDate: data.period.endDate
                    ? new Date(data.period.endDate).toISOString().split("T")[0]
                    : ""
                }
              : undefined,
            signatures: data.signatures || [],
            metadata: data.metadata || {},
            autoGenerated: data.autoGenerated,
            teamId: data.teamId,
            hackathonId: data.hackathonId,
            originCertificateId: data.originCertificateId
          });
        } catch {
          newErrorToast(t("loadError"));
          goList();
        }
      })();
    }
  }, [mode, editingId, t]);

  const handleCreate = async (data: CertificateFormData) => {
    try {
      const token = await getCsrfToken();
      const headers = { "x-csrf-token": token || "" };

      const payload = {
        ...data,
        recipient: {
          ...data.recipient,
          userId: data.recipient.userId || undefined
        },
        period:
          data.period?.startDate || data.period?.endDate
            ? {
                startDate: data.period.startDate || new Date().toISOString(),
                endDate: data.period.endDate || undefined
              }
            : undefined,
        signatures: data.signatures.length > 0 ? data.signatures : undefined,
        metadata: Object.keys(data.metadata).length > 0 ? data.metadata : undefined
      };

      const { error } = await api.admin.certificates.post(payload, { headers });

      if (!error) {
        newSuccessToast(t("created"));
        goList();
      } else {
        newErrorToast(t("createError"));
      }
    } catch {
      newErrorToast(t("createError"));
    }
  };

  const handleEdit = async (data: CertificateFormData) => {
    if (!editingId) return;

    try {
      const token = await getCsrfToken();
      const headers = { "x-csrf-token": token || "" };

      const payload = {
        ...data,
        recipient: {
          ...data.recipient,
          userId: data.recipient.userId || undefined
        },
        period:
          data.period?.startDate || data.period?.endDate
            ? {
                startDate: data.period.startDate || undefined,
                endDate: data.period.endDate || undefined
              }
            : undefined,
        signatures: data.signatures.length > 0 ? data.signatures : undefined,
        metadata: Object.keys(data.metadata).length > 0 ? data.metadata : undefined
      };

      const { error } = await api.admin.certificates({ id: editingId }).patch(payload, { headers });

      if (!error) {
        newSuccessToast(t("updated"));
        goList();
      } else {
        newErrorToast(t("updateError"));
      }
    } catch {
      newErrorToast(t("updateError"));
    }
  };

  const handleTeamEmit = async (data: CertificateFormData) => {
    try {
      const token = await getCsrfToken();
      const headers = { "x-csrf-token": token || "" };

      // Omit recipient
      // eslint-disable-next-line @typescript-eslint/no-unused-vars
      const { recipient, ...baseInput } = data;

      const payload = {
        ...baseInput,
        description: baseInput.description || undefined,
        period:
          baseInput.period?.startDate || baseInput.period?.endDate
            ? {
                startDate: baseInput.period.startDate || new Date().toISOString(),
                endDate: baseInput.period.endDate || undefined
              }
            : undefined,
        signatures: baseInput.signatures.length > 0 ? baseInput.signatures : undefined,
        metadata: Object.keys(baseInput.metadata).length > 0 ? baseInput.metadata : undefined
      };

      const { error } = await api.admin.certificates.team({ teamId }).post(payload, { headers });

      if (!error) {
        newSuccessToast(t("created"));
        goList();
      } else {
        newErrorToast(t("createError"));
      }
    } catch {
      newErrorToast(t("createError"));
    }
  };

  const handleDelete = async (id: string) => {
    try {
      const token = await getCsrfToken();
      const headers = { "x-csrf-token": token || "" };
      const { error } = await api.admin.certificates({ id }).delete(null, {
        headers,
        query: { group: "true" }
      });

      if (!error) {
        newSuccessToast(t("deleted"));
        setRefreshToken((x) => x + 1);
      } else {
        newErrorToast(t("deleteError"));
      }
    } catch {
      newErrorToast(t("deleteError"));
    }
  };

  const handleRevoke = async (ids: string[]) => {
    try {
      const token = await getCsrfToken();
      const headers = { "x-csrf-token": token || "" };
      const { error } = await api.admin.certificates.bulk.revoke.post(
        { ids, reason: undefined },
        { headers }
      );

      if (!error) {
        newSuccessToast(t("revoked"));
        setRefreshToken((x) => x + 1);
      } else {
        newErrorToast(t("revokeError"));
      }
    } catch {
      newErrorToast(t("revokeError"));
    }
  };

  const handleReinstate = async (ids: string[]) => {
    try {
      const token = await getCsrfToken();
      const headers = { "x-csrf-token": token || "" };
      const { error } = await api.admin.certificates.bulk.reinstate.post({ ids }, { headers });

      if (!error) {
        newSuccessToast(t("reinstated"));
        setRefreshToken((x) => x + 1);
      } else {
        newErrorToast(t("reinstateError"));
      }
    } catch {
      newErrorToast(t("reinstateError"));
    }
  };

  const [previewData, setPreviewData] = useState<{
    title: string;
    description?: string;
    type: "COURSE_COMPLETION" | "EVENT_ACHIEVEMENT" | "PARTICIPATION" | "VOLUNTEER";
    recipient: { name: string };
    designId: string;
    period?: { startDate?: string; endDate?: string };
    signatures?: Array<{ name?: string; role?: string }>;
    metadata?: Record<string, unknown>;
  } | null>(null);

  useEffect(() => {
    if (mode === "preview" && previewId) {
      (async () => {
        try {
          const { data, error } = await api.admin.certificates({ id: previewId }).get();
          if (error || !data) return;

          setPreviewData({
            title: data.title,
            description: data.description || undefined,
            type: data.type,
            recipient: {
              name: data.recipient.name
            },
            designId: data.designId,
            period: data.period
              ? {
                  startDate: data.period.startDate
                    ? new Date(data.period.startDate).toISOString().split("T")[0]
                    : undefined,
                  endDate: data.period.endDate
                    ? new Date(data.period.endDate).toISOString().split("T")[0]
                    : undefined
                }
              : undefined,
            signatures: data.signatures || [],
            metadata: data.metadata
          });
        } catch {
          setPreviewData(null);
        }
      })();
    }
  }, [mode, previewId]);

  return (
    <Container>
      <AdminBreadcrumbs
        items={[
          { label: tBreadcrumbs("admin"), href: "/admin" },
          { label: tBreadcrumbs("hackathons"), href: "/admin/hackathons" },
          { label: hackathon?.title || "...", href: `/admin/hackathons/${id}` },
          { label: tTeams("management"), href: `/admin/hackathons/${id}/teams` },
          { label: team?.name || "..." },
          { label: tBreadcrumbs("certificates"), href: "#" }
        ]}
      />

      <Header>
        <Title>{tPage("title")}</Title>
        <Subtitle>{team?.name}</Subtitle>
      </Header>

      <div style={{ marginBottom: "20px", display: "flex", gap: "10px" }}>
        <BackButton onClick={() => router.push(`/admin/hackathons/${id}/teams`)}>
          {tPage("backToList")}
        </BackButton>
      </div>

      {mode === "list" && (
        <CertificateList
          onCreate={onEmitBulk}
          onEdit={onEdit}
          onView={onView}
          onDelete={handleDelete}
          onDuplicate={() => {}} // Disabled for now
          onRevoke={handleRevoke}
          onReinstate={handleReinstate}
          refreshToken={refreshToken}
          teamId={teamId}
          hackathonId={id}
          grouped={true}
          createLabel={tTeams("emitCertificates")}
          teamName={team?.name}
        />
      )}

      {mode === "create" && (
        <CertificateForm
          initial={initial}
          onCancel={goList}
          onSubmit={handleCreate}
          teamMode
          teamName={team?.name}
        />
      )}

      {mode === "edit" && initial && (
        <CertificateForm
          initial={initial}
          onCancel={goList}
          onSubmit={handleEdit}
          teamMode
          teamName={team?.name}
        />
      )}

      {mode === "team-emit" && (
        <CertificateForm
          initial={initial}
          onCancel={goList}
          onSubmit={handleTeamEmit}
          teamMode
          teamName={team?.name}
        />
      )}

      {mode === "preview" && previewData && (
        <div style={{ background: "white", padding: "20px", borderRadius: "8px" }}>
          <Certificate data={previewData} />
          <div style={{ marginTop: "20px" }}>
            <BackButton onClick={goList}>{tPage("backToList")}</BackButton>
          </div>
        </div>
      )}
    </Container>
  );
}
