import db from "@/lib/db";
import Team, { ITeam, ITeamUser } from "@/lib/models/Team";
import Certificate, { ICertificate } from "@/lib/models/Certificate";
import crypto from "crypto";

export type TeamInput = {
  name: string;
  hackathonId: string;
  trackId?: string | null;
  projectDescription?: string;
  users?: ITeamUser[];
};

function generatePassword(length = 8): string {
  const charset = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";
  let retVal = "";
  const values = new Uint32Array(length);
  crypto.getRandomValues(values);
  for (let i = 0; i < length; i++) {
    retVal += charset[values[i] % charset.length];
  }
  return retVal;
}

async function getUniquePassword(hackathonId: string): Promise<string> {
  let password = "";
  let exists = true;
  while (exists) {
    password = generatePassword();
    const existing = await Team.findOne({ hackathonId, password });
    if (!existing) exists = false;
  }
  return password;
}

export async function createTeam(input: TeamInput): Promise<ITeam> {
  await db.connect();
  const password = await getUniquePassword(input.hackathonId);

  const data = {
    ...input,
    password,
    trackId: input.trackId ?? undefined
  };

  const team = await Team.create(data);
  const result = team.toObject() as unknown as ITeam;

  return result;
}

export async function updateTeam(
  id: string,
  input: Partial<Omit<TeamInput, "hackathonId">>
): Promise<ITeam | null> {
  await db.connect();

  // Fetch old team state for sync logic
  const oldTeam = (await Team.findById(id).lean()) as unknown as ITeam | null;

  const update = {
    ...input,
    trackId: input.trackId ?? undefined
  };

  let team: ITeam | null = null;

  if (input.trackId === null) {
    team = (await Team.findByIdAndUpdate(
      id,
      { ...update, $unset: { trackId: 1 } },
      { new: true }
    ).lean()) as unknown as ITeam | null;
  } else {
    team = (await Team.findByIdAndUpdate(id, update, {
      new: true
    }).lean()) as unknown as ITeam | null;
  }

  // Sync with certificates
  if (oldTeam && team) {
    // 1. Sync Team Name
    if (oldTeam.name !== team.name) {
      await Certificate.updateMany(
        { teamId: team._id, type: "EVENT_ACHIEVEMENT" },
        { $set: { "metadata.group": team.name } }
      );
    }

    // 2. Sync Members
    const oldMembers = oldTeam.users || [];
    const newMembers = team.users || [];

    const oldIds = new Set(oldMembers.map((u) => u.id));
    const newIds = new Set(newMembers.map((u) => u.id));

    const addedMembers = newMembers.filter((u) => !oldIds.has(u.id));
    const removedMembers = oldMembers.filter((u) => !newIds.has(u.id));

    // Process Removed Members
    if (removedMembers.length > 0) {
      await Certificate.deleteMany({
        teamId: team._id,
        autoGenerated: true,
        memberId: { $in: removedMembers.map((u) => u.id) }
      });
    }

    // Process Added Members
    if (addedMembers.length > 0) {
      // Find existing auto-generated certificates to use as templates
      const existingCerts = await Certificate.find({
        teamId: team._id,
        autoGenerated: true
      }).lean();

      // Group by groupId to avoid duplicates (one cert per "batch")
      const templates = new Map<string, ICertificate>();
      for (const cert of existingCerts) {
        if (cert.groupId && !templates.has(cert.groupId)) {
          templates.set(cert.groupId, cert);
        }
      }

      // Create new certificates for added members
      for (const member of addedMembers) {
        for (const template of templates.values()) {
          // eslint-disable-next-line @typescript-eslint/no-unused-vars
          const { _id, createdAt, updatedAt, recipient, memberId, ...baseData } = template;

          await Certificate.create({
            ...baseData,
            recipient: {
              name: member.name,
              userId: /^[0-9a-fA-F]{24}$/.test(member.id) ? member.id : undefined
            },
            memberId: member.id,
            revoked: { isRevoked: false }
          });
        }
      }
    }
  }

  return team;
}

export async function deleteTeam(id: string): Promise<boolean> {
  await db.connect();
  const res = await Team.findByIdAndDelete(id);
  if (res) {
    await Certificate.deleteMany({ teamId: id });
  }
  return !!res;
}

export async function listTeams(params: {
  hackathonId?: string;
  page?: number;
  pageSize?: number;
}): Promise<{
  items: ITeam[];
  total: number;
  page: number;
  pageSize: number;
}> {
  await db.connect();
  const { hackathonId, page = 1, pageSize = 10 } = params || {};

  const filter: Record<string, unknown> = {};
  if (hackathonId) {
    filter.hackathonId = hackathonId;
  }

  const total = await Team.countDocuments(filter);
  const items = await Team.find(filter)
    .populate("trackId")
    .sort({ name: 1 })
    .skip((page - 1) * pageSize)
    .limit(pageSize)
    .lean();

  const itemsWithCounts = await Promise.all(
    items.map(async (item) => {
      const groups = await Certificate.aggregate([
        { $match: { teamId: item._id } },
        {
          $group: {
            _id: {
              $ifNull: ["$groupId", { $concat: ["$title", "|", "$type", "|", "$designId"] }]
            }
          }
        },
        { $count: "total" }
      ]);

      return {
        ...item,
        certificateCount: groups[0]?.total || 0
      };
    })
  );

  return {
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    items: itemsWithCounts as any,
    total,
    page,
    pageSize
  };
}

export async function getTeamById(id: string): Promise<ITeam | null> {
  await db.connect();
  const team = await Team.findById(id).populate("trackId").lean();
  return team as unknown as ITeam | null;
}
