import db from "@/lib/db";
import mongoose from "mongoose";
import Certificate, {
  IRecipient,
  ICertificate,
  CertificateType,
  ISignature,
  ICourseCompletionMetadata,
  IEventAchievementMetadata,
  IParticipationMetadata,
  IVolunteerMetadata
} from "@/lib/models/Certificate";
import Team from "@/lib/models/Team";
import Hackathon, { IHackathon } from "@/lib/models/Hackathon";
import type { SortOrder, Types } from "mongoose";
import * as nodeCrypto from "node:crypto";

// Input types for creating/updating certificates (use strings for API input)
export type CertificateInputRecipient = IRecipient;

export type CertificateInputPeriod = {
  startDate: Date;
  endDate?: Date;
};

export type CertificateInput = {
  recipient: CertificateInputRecipient;
  designId: string;
  signatures?: ISignature[];
  period?: CertificateInputPeriod;
  title: string;
  description?: string;
  autoGenerated?: boolean;
  teamId?: string | Types.ObjectId;
  hackathonId?: string | Types.ObjectId;
  memberId?: string;
  originCertificateId?: string | Types.ObjectId;
} & (
  | { type: "COURSE_COMPLETION"; metadata?: ICourseCompletionMetadata }
  | { type: "EVENT_ACHIEVEMENT"; metadata: IEventAchievementMetadata }
  | { type: "PARTICIPATION"; metadata: IParticipationMetadata }
  | { type: "VOLUNTEER"; metadata: IVolunteerMetadata }
);

export type CertificateUpdateInput = Partial<Omit<CertificateInput, "type">> & {
  revoke?: {
    isRevoked: boolean;
    reason?: string;
  };
};

export type SortTypes = "newest" | "oldest";

/**
 * Create a new certificate in the database.
 */
export async function createCertificate(input: CertificateInput): Promise<ICertificate> {
  await db.connect();

  const finalInput = { ...input };

  // If hackathonId is provided, pull defaults
  if (input.hackathonId) {
    const hackathon = await Hackathon.findById(input.hackathonId);
    if (hackathon) {
      // Use hackathon title and dates by default
      if (!input.title) finalInput.title = hackathon.title;
      if (!input.period) {
        finalInput.period = {
          startDate: hackathon.date,
          endDate: hackathon.endDate
        };
      }

      // Use certificate defaults from hackathon if not provided
      if (hackathon.certificateDefaults) {
        if (!input.title && hackathon.certificateDefaults.title) {
          finalInput.title = hackathon.certificateDefaults.title;
        }
        if (!input.signatures || input.signatures.length === 0) {
          finalInput.signatures = hackathon.certificateDefaults.signatures;
        }
      }
    }
  }

  const certificate = await Certificate.create({
    ...finalInput,
    revoked: { isRevoked: false }
  });

  return certificate as ICertificate;
}

/**
 * Update an existing certificate by its _ID.
 */
export async function updateCertificate(
  id: string,
  input: CertificateUpdateInput
): Promise<ICertificate | null> {
  await db.connect();

  const certificate = await Certificate.findById(id);
  if (!certificate) return null;

  // Handle group syncing
  if (certificate.groupId) {
    const sharedUpdates: Partial<ICertificate> = {};
    if (input.designId !== undefined) sharedUpdates.designId = input.designId;
    if (input.signatures !== undefined) sharedUpdates.signatures = input.signatures;
    if (input.period !== undefined) sharedUpdates.period = input.period;
    if (input.title !== undefined) sharedUpdates.title = input.title;
    if (input.description !== undefined) sharedUpdates.description = input.description;
    if (input.metadata !== undefined) sharedUpdates.metadata = input.metadata;
    if (input.autoGenerated !== undefined) sharedUpdates.autoGenerated = input.autoGenerated;
    if (input.teamId !== undefined) sharedUpdates.teamId = input.teamId as Types.ObjectId;
    if (input.hackathonId !== undefined)
      sharedUpdates.hackathonId = input.hackathonId as Types.ObjectId;
    if (input.originCertificateId !== undefined)
      sharedUpdates.originCertificateId = input.originCertificateId as Types.ObjectId;

    if (Object.keys(sharedUpdates).length > 0) {
      await Certificate.updateMany(
        { groupId: certificate.groupId },
        { $set: sharedUpdates },
        { strict: false }
      );
    }
  }

  // Update basic fields
  if (input.recipient !== undefined) certificate.recipient = input.recipient;
  if (input.designId !== undefined) certificate.designId = input.designId;
  if (input.signatures !== undefined) certificate.signatures = input.signatures;
  if (input.period !== undefined) certificate.period = input.period;
  if (input.title !== undefined) certificate.title = input.title;
  if (input.description !== undefined) certificate.description = input.description;
  if (input.metadata !== undefined) certificate.metadata = input.metadata;

  // Update auto-generation fields if provided
  if (input.autoGenerated !== undefined) certificate.autoGenerated = input.autoGenerated;
  if (input.teamId !== undefined) certificate.teamId = input.teamId as Types.ObjectId;
  if (input.hackathonId !== undefined)
    certificate.hackathonId = input.hackathonId as Types.ObjectId;
  if (input.memberId !== undefined) certificate.memberId = input.memberId;
  if (input.originCertificateId !== undefined)
    certificate.originCertificateId = input.originCertificateId as Types.ObjectId;

  // Handle revocation
  if (input.revoke !== undefined) {
    certificate.revoked = {
      isRevoked: input.revoke.isRevoked,
      reason: input.revoke.reason,
      revokedAt: certificate.revoked?.revokedAt // Will be set by pre-save hook if needed
    };
  }

  await certificate.save();

  return certificate as ICertificate;
}

/**
 * Remove a certificate by its _ID.
 */
export async function deleteCertificate(
  id: string,
  deleteGroup: boolean = false
): Promise<boolean> {
  await db.connect();

  if (deleteGroup) {
    const cert = await Certificate.findById(id);
    if (cert) {
      if (cert.groupId) {
        const res = await Certificate.deleteMany({ groupId: cert.groupId });
        return res.deletedCount > 0;
      } else {
        // Implicit group deletion: delete all certificates with same properties
        const criteria: Record<string, unknown> = {
          title: cert.title,
          type: cert.type,
          designId: cert.designId
        };

        // Handle teamId
        if (cert.teamId) {
          criteria.teamId = cert.teamId;
        } else {
          criteria.teamId = { $in: [null, undefined] };
        }

        // Handle hackathonId (scope to same hackathon if present)
        if (cert.hackathonId) {
          criteria.hackathonId = cert.hackathonId;
        }

        const res = await Certificate.deleteMany(criteria);
        return res.deletedCount > 0;
      }
    }
  }

  const res = await Certificate.findByIdAndDelete(id);
  return !!res;
}

/**
 * Get a certificate by its _ID.
 */
export async function getCertificateById(id: string): Promise<ICertificate | null> {
  await db.connect();
  const certificate = await Certificate.findById(id).lean();
  return certificate as ICertificate | null;
}

/**
 * Get certificates by recipient user ID.
 */
export async function getCertificatesByUserId(userId: string): Promise<ICertificate[]> {
  await db.connect();
  const certificates = await Certificate.find({ "recipient.userId": userId })
    .sort({ createdAt: -1 })
    .lean();
  return certificates as unknown as ICertificate[];
}

/**
 * Revoke a certificate by its _ID.
 */
export async function revokeCertificate(id: string, reason?: string): Promise<ICertificate | null> {
  await db.connect();

  const certificate = await Certificate.findById(id);
  if (!certificate) return null;

  certificate.revoked = {
    isRevoked: true,
    reason,
    revokedAt: undefined // Will be set by pre-save hook
  };

  await certificate.save();
  return certificate as ICertificate;
}

/**
 * Reinstate a revoked certificate by its _ID.
 */
export async function reinstateCertificate(id: string): Promise<ICertificate | null> {
  await db.connect();

  const certificate = await Certificate.findByIdAndUpdate(
    id,
    {
      $set: {
        "revoked.isRevoked": false,
        "revoked.reason": undefined,
        "revoked.revokedAt": undefined
      }
    },
    { new: true }
  ).lean();

  return certificate as ICertificate | null;
}

/**
 * Bulk revoke certificates by IDs.
 */
export async function bulkRevokeCertificates(ids: string[], reason?: string): Promise<boolean> {
  await db.connect();
  const res = await Certificate.updateMany(
    { _id: { $in: ids } },
    {
      $set: {
        "revoked.isRevoked": true,
        "revoked.reason": reason,
        // revokedAt will be missing unless we set it, but that's acceptable for now
        // or we can set it:
        "revoked.revokedAt": new Date()
      }
    }
  );
  return res.modifiedCount > 0;
}

/**
 * Bulk reinstate certificates by IDs.
 */
export async function bulkReinstateCertificates(ids: string[]): Promise<boolean> {
  await db.connect();
  const res = await Certificate.updateMany(
    { _id: { $in: ids } },
    {
      $set: {
        "revoked.isRevoked": false,
        "revoked.reason": undefined,
        "revoked.revokedAt": undefined
      }
    }
  );
  return res.modifiedCount > 0;
}

/**
 * List certificates with filters, pagination, and sorting.
 */
export async function listCertificates(params?: {
  type?: CertificateType;
  recipientUserId?: string;
  includeRevoked?: boolean;
  includeAutoGenerated?: boolean;
  page?: number;
  pageSize?: number;
  sort?: SortTypes;
  search?: string;
  teamId?: string;
  hackathonId?: string;
  grouped?: boolean;
}): Promise<{
  items: (ICertificate & {
    count?: number;
    recipients?: { name: string; id: string }[];
    isGroup?: boolean;
  })[];
  total: number;
  page: number;
  pageSize: number;
}> {
  await db.connect();

  const {
    type,
    recipientUserId,
    includeRevoked = false,
    includeAutoGenerated = false,
    page = 1,
    pageSize = 10,
    sort = "newest",
    search,
    teamId,
    hackathonId,
    grouped = false
  } = params || {};

  const filter: Record<string, unknown> = {};

  // Filter by type
  if (type) {
    filter.type = type;
  }

  // Filter by recipient user ID
  if (recipientUserId && mongoose.Types.ObjectId.isValid(recipientUserId)) {
    filter["recipient.userId"] = new mongoose.Types.ObjectId(recipientUserId);
  }

  // Filter by team ID
  if (teamId && mongoose.Types.ObjectId.isValid(teamId)) {
    filter.teamId = new mongoose.Types.ObjectId(teamId);
  }

  // Filter by hackathon ID
  if (hackathonId && mongoose.Types.ObjectId.isValid(hackathonId)) {
    filter.hackathonId = new mongoose.Types.ObjectId(hackathonId);
  }

  // Exclude revoked certificates unless explicitly requested
  if (!includeRevoked) {
    filter["revoked.isRevoked"] = { $ne: true };
  }

  // Exclude auto-generated certificates unless explicitly requested
  if (!includeAutoGenerated) {
    filter.autoGenerated = { $ne: true };
  }

  // Search by title or recipient name
  if (search && search.trim()) {
    const searchRegex = new RegExp(search.trim(), "i");
    filter.$or = [{ title: searchRegex }, { "recipient.name": searchRegex }];
  }

  const sortMap: Record<SortTypes, Record<string, SortOrder>> = {
    newest: { createdAt: -1 },
    oldest: { createdAt: 1 }
  };

  const total = await Certificate.countDocuments(filter);

  if (grouped) {
    // Grouping logic for "Templates"
    // We group by groupId if it exists, otherwise by (title, type, designId, teamId)
    const pipeline: mongoose.PipelineStage[] = [
      { $match: filter },
      { $sort: { createdAt: sort === "newest" ? -1 : 1 } },
      {
        $group: {
          _id: {
            $ifNull: [
              "$groupId",
              {
                $concat: [
                  "$title",
                  "|",
                  "$type",
                  "|",
                  "$designId",
                  "|",
                  { $toString: { $ifNull: ["$teamId", "none"] } }
                ]
              }
            ]
          },
          count: { $sum: 1 },
          doc: { $first: "$$ROOT" },
          recipients: {
            $push: {
              name: "$recipient.name",
              id: "$_id"
            }
          }
        }
      },
      {
        $replaceRoot: {
          newRoot: {
            $mergeObjects: [
              "$doc",
              {
                count: "$count",
                recipients: "$recipients",
                isGroup: true
              }
            ]
          }
        }
      },
      { $sort: { createdAt: sort === "newest" ? -1 : 1 } },
      { $skip: (page - 1) * pageSize },
      { $limit: pageSize }
    ];

    const results = await Certificate.aggregate(pipeline);

    // For total count of groups, we actually need to count the groups
    const totalGroupsPipeline: mongoose.PipelineStage[] = [
      { $match: filter },
      {
        $group: {
          _id: {
            $ifNull: [
              "$groupId",
              {
                $concat: [
                  "$title",
                  "|",
                  "$type",
                  "|",
                  "$designId",
                  "|",
                  { $toString: { $ifNull: ["$teamId", "none"] } }
                ]
              }
            ]
          }
        }
      },
      { $count: "total" }
    ];
    const totalCountRes = await Certificate.aggregate(totalGroupsPipeline);
    const totalCountGroups = totalCountRes[0]?.total || 0;

    return {
      items: results,
      total: totalCountGroups,
      page,
      pageSize
    };
  }

  const items = await Certificate.find(filter)
    .sort(sortMap[sort])
    .skip((page - 1) * pageSize)
    .limit(pageSize)
    .lean();

  return { items: items as unknown as ICertificate[], total, page, pageSize };
}

/**
 * Verify a certificate by its _ID (for public verification endpoint).
 * Returns null if certificate doesn't exist or is revoked.
 */
export async function verifyCertificate(
  id: string
): Promise<{ valid: boolean; certificate: ICertificate | null; revokedReason?: string }> {
  await db.connect();

  const certificate = (await Certificate.findById(id).lean()) as ICertificate | null;

  if (!certificate) {
    return { valid: false, certificate: null };
  }

  if (certificate.revoked?.isRevoked) {
    return {
      valid: false,
      certificate,
      revokedReason: certificate.revoked.reason
    };
  }

  return { valid: true, certificate };
}

/**
 * Create certificates for everyone in a team.
 */
export async function createTeamCertificates(
  teamId: string,
  baseInput: Omit<CertificateInput, "recipient">
) {
  await db.connect();

  const team = await Team.findById(teamId).populate("hackathonId");
  if (!team) throw new Error("Team not found");

  const hackathon = team.hackathonId as unknown as IHackathon;

  if (!hackathon) throw new Error("Hackathon not found");

  const title = baseInput.title || hackathon.certificateDefaults?.title || hackathon.title;
  const signatures =
    baseInput.signatures && baseInput.signatures.length > 0
      ? baseInput.signatures
      : hackathon.certificateDefaults?.signatures || [];
  const period = baseInput.period || {
    startDate: hackathon.date,
    endDate: hackathon.endDate
  };

  const groupId = nodeCrypto.randomBytes(16).toString("hex");

  for (const member of team.users) {
    await Certificate.create({
      ...baseInput,
      groupId,
      title,
      signatures,
      period,
      recipient: {
        name: member.name,
        userId: /^[0-9a-fA-F]{24}$/.test(member.id) ? member.id : undefined
      },
      autoGenerated: true,
      teamId: team._id,
      hackathonId: hackathon?._id,
      memberId: member.id,
      revoked: { isRevoked: false }
    } as unknown as ICertificate);
  }
}

/**
 * Sync all certificates for a hackathon.
 */
export async function syncHackathonCertificates(hackathonId: string) {
  await db.connect();
  const hackathon = await Hackathon.findById(hackathonId);
  if (!hackathon) return;

  const title = hackathon.certificateDefaults?.title || hackathon.title;

  await Certificate.updateMany(
    { hackathonId: hackathonId as unknown as Types.ObjectId },
    {
      $set: {
        title: title,
        period: {
          startDate: hackathon.date,
          endDate: hackathon.endDate
        }
      }
    }
  );
}
